#!/usr/bin/env node
module.exports = Velveeva;

function Velveeva(configRecipe) {
  var CONFIG = {
    MAIN: {}
  };

  this.config = CONFIG;

  var VERBOSE = false;

  var Metalsmith = require('metalsmith'),
    collections = require('metalsmith-collections'),
    ignore  = require('metalsmith-ignore'),
    templates  = require('metalsmith-templates'),
    partial = require('metalsmith-partial'),
    sass = require('metalsmith-sass'),
    assets = require('./lib/assets-recursive.js');

  var fs = require('graceful-fs'),
    path = require('path'),
    Q = require('q'),
    rimraf = require('rimraf'),
    mkdirp = require('mkdirp'),
    ___ = require('lodash');

  var configRecipe = configRecipe || {};

  CONFIG.MAIN.ASSETS = configRecipe.MAIN.globals_dir || "./global_includes";
  CONFIG.MAIN.DEST = configRecipe.MAIN.output_dir || "./build";
  CONFIG.MAIN.PARTIALS = configRecipe.MAIN.partials_dir || "./partials/sections";
  CONFIG.MAIN.SOURCE = configRecipe.MAIN.source_dir || "./src";
  CONFIG.MAIN.TEMP = configRecipe.MAIN.temp_dir || "./temp";
  CONFIG.MAIN.TEMPLATES = configRecipe.MAIN.templates_dir || "./partials/full_templates";

  if (configRecipe.SS) {
    CONFIG.SS = CONFIG.SS || configRecipe.SS;
  }

  function buildPromise(metalsmith) {
    var deferred = Q.defer();
    metalsmith.build(function (err, data) {
      if (err) {
        deferred.reject(err);
      } else {
        deferred.resolve(data);
      }
    });
    return deferred.promise;
  }

  Metalsmith.prototype.buildPromise = function () {
    var deferred = Q.defer();
    this.build(function (err, data) {
      if (err) {
        deferred.reject(err);
      } else {
        deferred.resolve(data);
      }
    });
    return deferred.promise;
  };

  function mkdir(dirname) {
    var deferred = Q.defer();
    mkdirp(dirname, function (err) {
      if (err) {
        console.log("error");

        deferred.reject(err);
      } else {
        deferred.resolve(dirname);
      }
    });

    return deferred.promise;
  }

  function rmdir(dirname) {
    var deferred = Q.defer();

    rimraf(dirname, function (err) {
      if (err) {
        deferred.reject(err);
      } else {
        deferred.resolve();
      }
    });

    return deferred.promise;
  }

  function rm(filename) {
    var deferred = Q.defer();
    fs.unlink(filename, function (err) {
      if (err) {
        deferred.reject(err);
      } else {
        deferred.resolve()
      }
    });

    return deferred.promise;
  }


  function getDirectories(srcpath) {
    return fs.readdirSync(srcpath).filter(function (file) {
      return fs.statSync(path.join(srcpath, file)).isDirectory();
    });
  }

  function getFiles(srcpath) {
    return fs.readdirSync(srcpath).filter(function (file) {
      return fs.statSync(path.join(srcpath, file)).isFile();
    });
  }

  function bake() {
    var deferred = Q.defer();

    var chalk = require('chalk');
    console.log(chalk.blue("‚§∑ Baking "));

    // make a temp directory
    mkdir(path.join(__dirname, CONFIG.MAIN.TEMP))
    // inline all partials, and insert globals
      .then(function () {
        var ms = new Metalsmith(__dirname)
          .source(CONFIG.MAIN.SOURCE)
          .destination(CONFIG.MAIN.TEMP)
          .use(collections({
            slide: {pattern: "**/index.html"}
          }))
          .use(partial({
            directory: CONFIG.MAIN.PARTIALS,
            engine: 'eco'
          }))
          .use(templates({
            directory: CONFIG.MAIN.TEMPLATES,
            engine: 'eco'
          }))
          .use(assets({
            source: CONFIG.MAIN.ASSETS,
            destination: ".",
            recursive: true
          }));
        return ms.buildPromise();
      })
      // compile sass
      .then(function () {
        console.log(chalk.blue("‚§∑ Mixing in SASS "));
        var ms = new Metalsmith(__dirname)
            .source(CONFIG.MAIN.TEMP)
            .destination(CONFIG.MAIN.DEST)
            .use(sass());
        return ms.buildPromise();
      })
      //re-link
      .then(function () {
      	console.log(chalk.blue("‚§∑ Whipping up assets and hyperlinks "));
      	return relink();
      })
      //take screenshots
      .then(function () {
        console.log(chalk.blue("‚§∑ Sprinkling with screenshots "));
        return screenshots();
      })
      // zip it all up
      .then(function () {
        console.log(chalk.blue("‚§∑ Bagging it up "));
        return pkg();
      })
      // clean up temp folder
      .then(function (err) {
        console.log(chalk.blue("‚§∑ Washing "));
        return rmdir(path.join(__dirname, CONFIG.MAIN.TEMP));
      })
      //.catch(function (err) { console.log(err); })
      .done(function () {
        console.log(chalk.green.bold("‚úîÔ∏é yum!üçï"));
        deferred.resolve();
      },
      function (err) {
        console.log(chalk.red.bold("‚úó üí© ") + err);
        deferred.reject(err);
      });

      return deferred.promise;
  }

  function relink() {
  	var deferred = Q.defer();

    var spawn = require('child_process').spawn;
    
    
    var shell = spawn('python3', [path.join(__dirname, './lib/re-link.py'), path.join(__dirname, CONFIG.MAIN.DEST)]);


    shell.stdout.on('data', function(data) {
	   if (VERBOSE) console.log(chalk.blue('stdout: ' + data));
	});

	shell.stderr.on('data', function (data) {
	  console.log(chalk.red.bold('stderr: ' + data));
	});

    shell.on('exit', function (status) {
      if (status === 0) {
        deferred.resolve();
      } else {
        deferred.reject('Linking script exited with status ' + status);
      }
    });

    return deferred.promise;

  }

  function screenshots() {
    var d = Q.defer();
    var baseDir = CONFIG.MAIN.DEST,
      basePath = path.join(__dirname, baseDir);
    var phantom = require('phantom'),
        im = require('imagemagick');

    var dirs = getDirectories(basePath);

    var sizes = CONFIG.SS || {
      full: {width: 1024, height: 768, name: "-full.jpg"},
      thumb: {width: 200, height: 150, name: "-thumb.jpg"}
    };

    function convertImage (opts) {
      var deferred = Q.defer();
      im.convert(opts, function(err) {
        if (err) {
          deferred.reject(err);
        };

        deferred.resolve();
      });

      return deferred.promise;
    }

    function renderPage (url, output) {
      var deferred = Q.defer();

      phantom.create(function (ph) {
        ph.createPage(function (page) {
          page.set('viewportSize', sizes.full);

          var completePath = url;

          page.open(completePath, function () {
            page.render(output+".png", function () {
              ph.exit();
              deferred.resolve();
            });
          });

        });
      });

      return deferred.promise;
    }

    function takeScreenshot (basePath, dir, matchingFile) {

          var deferred = Q.defer();

          var full = dir, //+ "-full",
            thumb = dir + "-thumb.png";

            var completePath = "file://" + path.join(basePath,dir,matchingFile),
                outputFile = path.join(basePath,dir,full);

          renderPage(completePath,outputFile)
            .then(function () { // convert to jpg
              return convertImage([outputFile+".png", '-background', 'white', '-flatten', outputFile+sizes.full.name]);
            })
            .then(function () { // resize jpg to thumbnail
              return convertImage([outputFile+sizes.full.name, '-resize', sizes.thumb.width+'x'+sizes.thumb.height, outputFile+sizes.thumb.name]);
            })
            .then(function () { // remove the original png
              rm(outputFile+".png");
            })
            .done(function () {
              deferred.resolve();
            }, function () {
              deferred.reject();
            });
          
          return deferred.promise;
    };

    var allScreenshots = ___(dirs)
      .map(function (dir) {
        var files = getFiles(path.join(basePath, dir));
        
        return ___(files)
          .filter(function (file) { 
            var regex = new RegExp(dir + ".htm", "g");
            return file.match(regex);
          })
          .map(function(matchingFile) { return takeScreenshot(basePath, dir, matchingFile); })
          .value(); // end matching

      })
      .flattenDeep()
      .value(); // create an array of promise-returning functions containing all the screenshots


    Q.all(allScreenshots).done(function() { // if all are accepted
      d.resolve(); // resolve the main promise
    }, function() { // if any are rejected
      d.reject();
    });

    return d.promise;
  } // end screenshots

  function pkg() {
    var deferred = Q.defer();

    var spawn = require('child_process').spawn;
    
    
    var shell = spawn('sh', [path.join(__dirname, './lib/package_slides.sh')], {
      cwd: path.join(__dirname, CONFIG.MAIN.DEST)
    });

    shell.stdout.on('data', function(data) {
    	if (VERBOSE) console.log(chalk.blue('stdout: ' + data));
	});

	shell.stderr.on('data', function (data) {
	  console.log(chalk.red.bold('stderr: ' + data));
	});

    shell.on('exit', function (status) {
      if (status === 0) {
        deferred.resolve();
      } else {
        deferred.reject('Packaging script exited with status ' + status);
      }
    });

    return deferred.promise;

  }

  function watch() {
      //let's watch
    return function () {
      var chalk = require('chalk');
      var OK = chalk.green.bold("‚úîÔ∏é yum! ");
      var ERR = chalk.red.bold("‚úó üí© ");

      var ASSETS = CONFIG.MAIN.ASSETS,
        DEST = CONFIG.MAIN.DEST,
        PARTIALS = CONFIG.MAIN.PARTIALS,
        SOURCE = CONFIG.MAIN.SOURCE,
        TEMP = CONFIG.MAIN.TEMP,
        TEMPLATES = CONFIG.MAIN.TEMPLATES;

      function watcher() {
        console.log(chalk.blue.bold("VELVEEVA"));
        //console.log(bake());

        bake().then(function () {
          console.log(chalk.blue("‚§∑ Watching for changes (^C to quit)..."));
        })
        .done(function() {
        /*
        console.log(chalk.blue("build: ") + DEST);
        console.log(chalk.blue("source: ") + SOURCE);
        console.log(chalk.blue("partials: ") + PARTIALS);
        console.log(chalk.blue("global assets: ") + ASSETS);
        console.log(chalk.blue("templates: ") + TEMPLATES);
        */
        require('chokidar')
          .watch([SOURCE, PARTIALS, ASSETS, TEMPLATES], {ignored: /[\/\\]\./, ignoreInitial: true})
          .on('all', function (event, path) {
            console.log(chalk.blue(event), path);
            bake().done(function () { console.log(OK); }, function (err) { console.log(ERR + err); });
          });
        });

      }

      return watcher();
    };
  }

  this.bake = bake;
  this.watch = watch(bake);
  this.pkg = pkg;

}


var configFile = require('./config.json');
var cliArgs = require("command-line-args");
var cli = cliArgs([
  { name: "watch", type: Boolean, alias: "w", description: "Watch for changes and re-bake on change" },
  { name: "bake", type: Boolean, alias: "b", defaultOption: true, descriptions: "Bake the Velveeva project"},
  { name: "package", type: Boolean, alias: "p", description: "Wrap it up"},
  { name: "help", type: Boolean, alias: "h", description: "--bake Bake it once \n --watch Bake and watch"}
]);

var options = cli.parse();
var V = new Velveeva(configFile);

if (options.watch) {
  V.watch();
} else {
  var chalk = require('chalk');
  console.log(chalk.blue.bold("VELVEEVA"));
  V.bake();
}