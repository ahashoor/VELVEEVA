#!/usr/bin/env node
module.exports = Velveeva;

function Velveeva(configRecipe) {
  var CONFIG = {
    MAIN: {}
  };

  this.config = CONFIG;

  CONFIG["FLAGS"] = {
    VERBOSE: false,
    DEV: false,
    RELINK: false,
    WATCH: false,
    PACKAGE: false,
    SCREENSHOTS: false,
    CLEAN: false
  };

  var Metalsmith = require('metalsmith'),
    collections = require('metalsmith-collections'),
    ignore  = require('metalsmith-ignore'),
    templates  = require('metalsmith-templates'),
    partial = require('metalsmith-partial'),
    sass = require('metalsmith-sass'),
    assets = require('./lib/assets-recursive.js');

  var chalk = require('chalk'),
    fs = require('graceful-fs'),
    path = require('path'),
    Q = require('q'),
    rimraf = require('rimraf'),
    mkdirp = require('mkdirp'),
    ___ = require('lodash');

  var configRecipe = configRecipe || {};

  CONFIG.MAIN.ASSETS = configRecipe.MAIN.globals_dir || "./global_includes";
  CONFIG.MAIN.DEST = configRecipe.MAIN.output_dir || "./build";
  CONFIG.MAIN.PARTIALS = configRecipe.MAIN.partials_dir || "./partials/sections";
  CONFIG.MAIN.SOURCE = configRecipe.MAIN.source_dir || "./src";
  CONFIG.MAIN.TEMP = configRecipe.MAIN.temp_dir || "./temp";
  CONFIG.MAIN.TEMPLATES = configRecipe.MAIN.templates_dir || "./partials/full_templates";

  if (configRecipe.SS) {
    CONFIG.SS = CONFIG.SS || configRecipe.SS;
  }

  function buildPromise(metalsmith) {
    var deferred = Q.defer();
    metalsmith.build(function (err, data) {
      if (err) {
        deferred.reject(err);
      } else {
        deferred.resolve(data);
      }
    });
    return deferred.promise;
  }

  Metalsmith.prototype.buildPromise = function () {
    var deferred = Q.defer();
    this.build(function (err, data) {
      if (err) {
        deferred.reject(err);
      } else {
        deferred.resolve(data);
      }
    });
    return deferred.promise;
  };

  function mkdir(dirname) {
    var deferred = Q.defer();
    mkdirp(dirname, function (err) {
      if (err) {
        console.log("error");

        deferred.reject(err);
      } else {
        deferred.resolve(dirname);
      }
    });

    return deferred.promise;
  }

  function rmdir(dirname) {
    var deferred = Q.defer();

    rimraf(dirname, function (err) {
      if (err) {
        deferred.reject(err);
      } else {
        deferred.resolve();
      }
    });

    return deferred.promise;
  }

  function rm(filename) {
    var deferred = Q.defer();
    fs.unlink(filename, function (err) {
      if (err) {
        deferred.reject(err);
      } else {
        deferred.resolve()
      }
    });

    return deferred.promise;
  }


  function getDirectories(srcpath) {
    return fs.readdirSync(srcpath).filter(function (file) {
      return fs.statSync(path.join(srcpath, file)).isDirectory();
    });
  }

  function getFiles(srcpath) {
    return fs.readdirSync(srcpath).filter(function (file) {
      return fs.statSync(path.join(srcpath, file)).isFile();
    });
  }

  function note(msg) { console.log(chalk.blue(msg)); }
  function error(msg) { console.log(chalk.red.bold("‚úó üí© ") + msg); }
  function success(msg) { console.log(chalk.green.bold("‚úîÔ∏é " + msg)); }
  function stdOut(msg) { console.log(chalk.gray(msg)); }

  function bake() {
    var deferred = Q.defer();
    note("‚§∑ Baking ");

    // make a temp directory
    mkdir(path.join(__dirname, CONFIG.MAIN.TEMP))
    // inline all partials, and insert globals
      .then(function () {
        var ms = new Metalsmith(__dirname)
          .source(CONFIG.MAIN.SOURCE)
          .destination(CONFIG.MAIN.TEMP)
          .use(partial({
            directory: CONFIG.MAIN.PARTIALS,
            engine: 'eco'
          }))
          .use(templates({
            directory: CONFIG.MAIN.TEMPLATES,
            engine: 'eco'
          }))
          .use(assets({
            source: CONFIG.MAIN.ASSETS,
            destination: ".",
            recursive: true
          }));
        return ms.buildPromise();
      })
      // compile sass
      .then(function () {
        note("‚§∑ Mixing in SASS ");
        var ms = new Metalsmith(__dirname)
            .source(CONFIG.MAIN.TEMP)
            .destination(CONFIG.MAIN.DEST)
            .use(sass());
        return ms.buildPromise();
      })
      //re-link
      .then(function () {
        if (!CONFIG.FLAGS.RELINK) {
          return function() { d = Q.Defer(); d.resolve("Short circuit"); return d.promise; };
        } else {
          note("‚§∑ Whipping up assets and hyperlinks ");
          return relink();
        }
      })
      //take screenshots
      .then(function () {
        if (CONFIG.FLAGS.SCREENSHOTS) {
          if (CONFIG.FLAGS.DEV) {
            console.log(chalk.blue("‚Äî Skipping screenshots (dev)"));
            return function() { d = Q.Defer(); d.resolve("Dev short circuit"); return d.promise; };
          } else {
            note("‚§∑ Sprinkling with screenshots ");
            return screenshots();
          }
        } else {
          return function() { d = Q.Defer(); d.resolve("Short circuit"); return d.promise; };
        }
      })
      // zip it all up
      .then(function () {
        if (CONFIG.FLAGS.PACKAGE) {
          if (CONFIG.FLAGS.DEV) {
            note("‚Äî Skipping packaging (dev)");
            return function() { d = Q.Defer(); d.resolve("Dev short circuit"); return d.promise; };
          } else {
            note("‚§∑ Bagging it up ");
            return pkg();
          }
        } else {
          return function() { d = Q.Defer(); d.resolve("Short circuit"); return d.promise; };
        }
      })
      // clean up temp folder
      .then(function (err) {
        if (CONFIG.FLAGS.CLEAN) {
          note("‚§∑ Washing ");
          return rmdir(path.join(__dirname, CONFIG.MAIN.TEMP));
        } else {
          return function() { d = Q.Defer(); d.resolve("Short circuit"); return d.promise; };
        }
      })
      //.catch(function (err) { console.log(err); })
      .done(function () {
        success("yum!üçï");
        deferred.resolve();
      },
      function (err) {
        error(err);
        deferred.reject(err);
      });

      return deferred.promise;
  }

  function relink() {
  	var deferred = Q.defer();

    var spawn = require('child_process').spawn;
    
    
    var shell = spawn('python3', [path.join(__dirname, './lib/re_link.py'), path.join(__dirname, CONFIG.MAIN.DEST)]);


    shell.stdout.on('data', function(data) {
	   if (CONFIG.FLAGS.VERBOSE) stdOut('stdout: ' + data);
	});

	shell.stderr.on('data', function (data) {
	 error('stderr: ' + data);
	});

    shell.on('exit', function (status) {
      if (status === 0) {
        deferred.resolve();
      } else {
        deferred.reject('Linking script exited with status ' + status);
      }
    });

    return deferred.promise;

  }

  function screenshots() {
    var d = Q.defer();

    var baseDir = CONFIG.MAIN.DEST,
      basePath = path.join(__dirname, baseDir);
    var phantom = require('phantom'),
        im = require('imagemagick');

    var dirs = getDirectories(basePath);

    var sizes = CONFIG.SS || {
      full: {width: 1024, height: 768, name: "-full.jpg"},
      thumb: {width: 200, height: 150, name: "-thumb.jpg"}
    };

    function convertImage (opts) {
      var deferred = Q.defer();
      im.convert(opts, function(err) {
        if (err) {
          deferred.reject(err);
        };

        deferred.resolve();
      });

      return deferred.promise;
    }

    function renderPage (url, output) {
      var deferred = Q.defer();

      phantom.create(function (ph) {
        ph.createPage(function (page) {
          page.set('viewportSize', sizes.full);

          var completePath = url;

          page.open(completePath, function () {
            page.render(output+".png", function () {
              ph.exit();
              deferred.resolve();
            });
          });

        });
      });

      return deferred.promise;
    }

    function takeScreenshot (basePath, dir, matchingFile) {

          var deferred = Q.defer();

          var full = dir, //+ "-full",
            thumb = dir + "-thumb.png";

            var completePath = "file://" + path.join(basePath,dir,matchingFile),
                outputFile = path.join(basePath,dir,full);

          renderPage(completePath,outputFile)
            .then(function () { // convert to jpg
              return convertImage([outputFile+".png", '-background', 'white', '-flatten', outputFile+sizes.full.name]);
            })
            .then(function () { // resize jpg to thumbnail
              return convertImage([outputFile+sizes.full.name, '-resize', sizes.thumb.width+'x'+sizes.thumb.height, outputFile+sizes.thumb.name]);
            })
            .then(function () { // remove the original png
              rm(outputFile+".png");
            })
            .done(function () {
              deferred.resolve();
            }, function () {
              deferred.reject();
            });
          
          return deferred.promise;
    };

    var allScreenshots = ___(dirs)
      .map(function (dir) {
        var files = getFiles(path.join(basePath, dir));
        
        return ___(files)
          .filter(function (file) { 
            var regex = new RegExp(dir + ".htm", "g");
            return file.match(regex);
          })
          .map(function(matchingFile) { return takeScreenshot(basePath, dir, matchingFile); })
          .value(); // end matching

      })
      .flattenDeep()
      .value(); // create an array of promise-returning functions containing all the screenshots


    Q.all(allScreenshots).done(function() { // if all are accepted
      d.resolve(); // resolve the main promise
    }, function() { // if any are rejected
      d.reject();
    });

    return d.promise;
  } // end screenshots

  function pkg() {
    var deferred = Q.defer();

    var spawn = require('child_process').spawn;
    var shell = spawn('sh', [path.join(__dirname, './lib/package_slides.sh')], {
      cwd: path.join(__dirname, CONFIG.MAIN.DEST)
    });

    shell.stdout.on('data', function(data) {
      	if (CONFIG.FLAGS.VERBOSE) stdOut('stdout: ' + data);
  	});

  	shell.stderr.on('data', function (data) {
  	  error('stderr: ' + data);
  	});

    shell.on('exit', function (status) {
      if (status === 0) {
        deferred.resolve();
      } else {
        deferred.reject('Packaging script exited with status ' + status);
      }
    });

    return deferred.promise;

  }

  function watch() {
      //let's watch
    return function () {

      var ASSETS = CONFIG.MAIN.ASSETS,
        DEST = CONFIG.MAIN.DEST,
        PARTIALS = CONFIG.MAIN.PARTIALS,
        SOURCE = CONFIG.MAIN.SOURCE,
        TEMP = CONFIG.MAIN.TEMP,
        TEMPLATES = CONFIG.MAIN.TEMPLATES;

      function watcher() {

        bake().then(function () {
          stdOut("‚§∑ Watching for changes (^C to quit)...");
        })
        .done(function() {
        /*
        console.log(chalk.blue("build: ") + DEST);
        console.log(chalk.blue("source: ") + SOURCE);
        console.log(chalk.blue("partials: ") + PARTIALS);
        console.log(chalk.blue("global assets: ") + ASSETS);
        console.log(chalk.blue("templates: ") + TEMPLATES);
        */
        require('chokidar')
          .watch([SOURCE, PARTIALS, ASSETS, TEMPLATES], {ignored: /[\/\\]\./, ignoreInitial: true})
          .on('all', function (event, path) {
            console.log(chalk.blue(event), path);
            bake().done(function () { success("yum!üçï"); }, function (err) { error(err); });
          });
        });

      }

      return watcher();
    };
  }

  function run() {
    console.log(chalk.blue.bold("VELVEEVA"));

    if (CONFIG.FLAGS.WATCH) {
      watch(bake)();
    } else {
      bake();
    }
  }

  this.pkg = pkg;
  this.run = run;

}


var configFile = require('./config.json');
var cliArgs = require("command-line-args");
var cli = cliArgs([
  { name: "watch", type: Boolean, alias: "w", description: "Watch for changes and re-bake on change" },
  { name: "dev", type: Boolean, alias: "dev", description: "Use the quick-bake test kitchen environment"},
  { name: "bake", type: Boolean, alias: "b", descriptions: "Bake the Velveeva project"},
  { name: "package", type: Boolean, alias: "p", description: "Wrap it up"},
  { name: "help", type: Boolean, alias: "h", description: "--bake Bake it once \n --watch Bake and watch \n --dev Quick and easy bake in the test kitchen"},
  { name: "verbose", type: Boolean, alias: "v", description: "Chatty Cathy"},
  { name: "relink", type: Boolean, alias: "r", description: "Make some href saussage..."},
  { name: "screenshots", type: Boolean, alias: "s", description: "Include Screenshots"},
  { name: "clean", type: Boolean, alias: "c", description: "Clean up the mess (mom would be proud!)"}
]);

var options = cli.parse();
var V = new Velveeva(configFile);

if (options.dev) V.config.FLAGS.DEV = true;
if (options.verbose) V.config.FLAGS.VERBOSE = true;
if (options.relink) V.config.FLAGS.RELINK = true;
if (options.watch) V.config.FLAGS.WATCH = true;
if (options.clean) V.config.FLAGS.CLEAN = true;
if (options.package) V.config.FLAGS.PACKAGE = true;

if (Object.keys(options).length === 0) {
  // default case
  V.config.FLAGS.PACKAGE = true;
  V.config.FLAGS.RELINK = false;
  V.config.FLAGS.SCREENSHOTS = true;
  V.config.FLAGS.CLEAN = true;

}

if (!options.help) {
    V.run();
}